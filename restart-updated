#!/bin/bash

function die {
    printf >&2 '%s: %s.\n' "$0" "$1"
    exit 1
}

function usage {
    printf 'Usage: %s [--exclude PATTERN | --include PATTERN | --no-default-excludes | --user | --system | --do-restart | --no-do-restart]...\n' "$0"
}

function die-with-usage {
    if (($#)); then
        printf >&2 '%s: %s.\n' "$0" "$1"
    fi
    usage >&2
    exit 1
}

# select: associative array from pattern to selection function
# true: select if not overridden by false for other matching pattern
# false: never select;
# exclude-by-default: don’t select, but trumped by “true” for other matching patterns and can be changed to mean select-by-default via --no-default-excludes
declare -A select=(
    ['*.socket']=exclude-by-default
    ['*.target']=exclude-by-default
    ['*.device']=exclude-by-default
    ['*.mount']=exclude-by-default
    ['*.automount']=exclude-by-default
    ['*.timer']=exclude-by-default
    ['*.swap']=exclude-by-default
    ['*.path']=exclude-by-default
    ['*.slice']=exclude-by-default
    ['*.scope']=exclude-by-default
    ['user@*.service']=exclude-by-default
)
function exclude-by-default { return 1; }
function select-by-default { return 0; }

mode=--system

function do-restart {
    case $mode in
        --system)
            if ((UID==0)); then true; else false; fi;;
        --user)
            false;;
        *)
            die 'Unknown mode';;
    esac
}

while (($#)); do
    case $1 in
        --exclude)
            if [[ -n "$2" ]]; then
                select["$2"]=false
            else
                die-with-usage 'Missing --exclude argument'
            fi
            shift 2
            ;;
        --include)
            if [[ -n "$2" ]]; then
                select["$2"]=true
                function select-by-default { return 1; }
            else
                die-with-usage 'Missing --include argument'
            fi
            shift 2
            ;;
        --no-default-excludes)
            function exclude-by-default { select-by-default; }
            shift 1
            ;;
        --system|--user)
            mode="$1"
            shift 1
            ;;
        --do-restart)
            function do-restart { true; }
            shift 1
            ;;
        --no-do-restart)
            function do-restart { false; }
            shift 1
            ;;
        --help) usage; exit;;
        -*) die-with-usage 'Unknown option';;
        *) die-with-usage 'Unexpected argument';;
    esac
done

function busctl {
    command busctl "$mode" "$@"
}

exec 3< <(lsof -F pf)
declare -i pid=0
declare -a pids=()
while IFS= read -r field; do
    case $field in
        p*) pid=${field:1};;
        f*) [[ "${field:1}" == "DEL" && (${#pids[@]} == 0 || ${pids[-1]} != "$pid") ]] && pids+=("$pid");;
        *) die 'Unexpected lsof output';;
    esac
done <&3

declare -a units=()
for pid in "${pids[@]}"; do
    unitOut=$(busctl call org.freedesktop.systemd1 /org/freedesktop/systemd1 org.freedesktop.systemd1.Manager GetUnitByPID u "$pid" 2>&1)
    (($? == 0)) || {
        # print error message unless it’s “unknown PID” in --user mode, which is expected
        if ! [[ "$unitOut" == "PID $pid does not belong to any loaded unit." && "$mode" == "--user" ]]; then
            printf >&2 '%s\n' "$unitOut"
        fi
        continue
    }
    IFS=' ' read -r type path rest <<< "$unitOut"
    [[ -z "$rest" ]] || die 'Unexpected GetUnitByPID trailing output'
    [[ "$type" == "o" ]] || die 'Unexpected GetUnitByPID return type'
    [[ "$path" == '"'*'"' ]] || die 'Unquoted path returned by GetUnitByPID'
    unit="${path:1:-1}"
    store=true
    for savedUnit in "${units[@]}"; do
        if [[ "$savedUnit" == "$unit" ]]; then
            store=false
            break
        fi
    done
    if "$store"; then
        units+=("$unit")
    fi
done

declare -A unitNames=()
for unitObject in "${units[@]}"; do
    unitNameOut=$(busctl get-property org.freedesktop.systemd1 "$unitObject" org.freedesktop.systemd1.Unit Id)
    (($? == 0)) || unitNames[$unitObject]=""
    IFS=' ' read -r type id rest <<< "$unitNameOut"
    [[ -z "$rest" ]] || die 'Unexpected Id trailing output'
    [[ "$type" == "s" ]] || die 'Unexpected Id type'
    [[ "$id" == '"'*'"' ]] || die 'Unquoted Id'
    name="${id:1:-1}"
    unitNames[$unitObject]="$name"
done

declare -A selectedUnitNames=()
for unitObject in "${!unitNames[@]}"; do
    unitName="${unitNames[$unitObject]}"
    selection=select-by-default
    for pattern in "${!select[@]}"; do
        newSelection="${select[$pattern]}"
        if [[ "$unitName" == $pattern ]]; then
            if [[ "$selection" == false ]]; then
                continue # cannot be overridden
            elif [[ "$newSelection" == false ]]; then
                selection="$newSelection" # overrides everything
            elif [[ "$selection" == *-by-default ]]; then
                selection="$newSelection" # overridden by everything
            fi
        fi
    done
    if "$selection"; then
        selectedUnitNames[$unitObject]="$unitName"
    fi
done

if ((${#selectedUnitNames[@]})); then
    printf 'Found %d units using deleted files:\n' "${#selectedUnitNames[@]}"
    printf '%s\n' "${selectedUnitNames[@]}"
    
    if do-restart; then
        read -r -N1 -p 'Do you want to restart these units? [y/N] ' doRestart
        [[ -z "$doRestart" ]] || printf '\n'
        case $doRestart in
            y|Y) ;;
            n|N) exit;;
            *) exit;;
        esac
    else
        exit
    fi
    systemctl "$mode" restart -- "${selectedUnitNames[@]}"
else
    printf 'Found 0 units using deleted files.\n'
fi
